/*
 * WCI Automap API
 * <p>API documentation for the West Coast Informatics Automated Term Mapping Service.</p><p>For developer documentation and examples, see on GitHub <a href=\"https://github.com/westCoastInformatics/wci-automap-in-5-minutes\">WCI Automap in 5 Minutes</a></p>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@westcoastinformatics.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.wci.automap.client.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.wci.automap.client.model.Metadata;
import com.wci.automap.client.model.Terminology;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.wci.automap.client.invoker.JSON;


/**
 * Represents all types of metadata associated with a terminology
 */
@JsonPropertyOrder({
  TerminologyMetadata.JSON_PROPERTY_TERM_TYPES,
  TerminologyMetadata.JSON_PROPERTY_LANGUAGES,
  TerminologyMetadata.JSON_PROPERTY_RELATIONSHIP_TYPES,
  TerminologyMetadata.JSON_PROPERTY_ADDITIONAL_RELATIONSHIP_TYPES,
  TerminologyMetadata.JSON_PROPERTY_ATTRIBUTE_NAMES,
  TerminologyMetadata.JSON_PROPERTY_OTHER,
  TerminologyMetadata.JSON_PROPERTY_SEMANTIC_TYPES,
  TerminologyMetadata.JSON_PROPERTY_TERMINOLOGY,
  TerminologyMetadata.JSON_PROPERTY_LOCAL,
  TerminologyMetadata.JSON_PROPERTY_MODIFIED_BY,
  TerminologyMetadata.JSON_PROPERTY_CREATED,
  TerminologyMetadata.JSON_PROPERTY_MODIFIED,
  TerminologyMetadata.JSON_PROPERTY_ID,
  TerminologyMetadata.JSON_PROPERTY_ACTIVE
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-03T12:31:07.733622100-08:00[America/Los_Angeles]", comments = "Generator version: 7.5.0")
public class TerminologyMetadata {
  public static final String JSON_PROPERTY_TERM_TYPES = "termTypes";
  private Map<String, Metadata> termTypes = new HashMap<>();

  public static final String JSON_PROPERTY_LANGUAGES = "languages";
  private Map<String, Metadata> languages = new HashMap<>();

  public static final String JSON_PROPERTY_RELATIONSHIP_TYPES = "relationshipTypes";
  private Map<String, Metadata> relationshipTypes = new HashMap<>();

  public static final String JSON_PROPERTY_ADDITIONAL_RELATIONSHIP_TYPES = "additionalRelationshipTypes";
  private Map<String, Metadata> additionalRelationshipTypes = new HashMap<>();

  public static final String JSON_PROPERTY_ATTRIBUTE_NAMES = "attributeNames";
  private Map<String, Metadata> attributeNames = new HashMap<>();

  public static final String JSON_PROPERTY_OTHER = "other";
  private Map<String, Metadata> other = new HashMap<>();

  public static final String JSON_PROPERTY_SEMANTIC_TYPES = "semanticTypes";
  private Map<String, Metadata> semanticTypes = new HashMap<>();

  public static final String JSON_PROPERTY_TERMINOLOGY = "terminology";
  private Terminology terminology;

  public static final String JSON_PROPERTY_LOCAL = "local";
  private Boolean local;

  public static final String JSON_PROPERTY_MODIFIED_BY = "modifiedBy";
  private String modifiedBy;

  public static final String JSON_PROPERTY_CREATED = "created";
  private Date created;

  public static final String JSON_PROPERTY_MODIFIED = "modified";
  private Date modified;

  public static final String JSON_PROPERTY_ID = "id";
  private UUID id;

  public static final String JSON_PROPERTY_ACTIVE = "active";
  private Boolean active;

  public TerminologyMetadata() { 
  }

  public TerminologyMetadata termTypes(Map<String, Metadata> termTypes) {
    this.termTypes = termTypes;
    return this;
  }

  public TerminologyMetadata putTermTypesItem(String key, Metadata termTypesItem) {
    if (this.termTypes == null) {
      this.termTypes = new HashMap<>();
    }
    this.termTypes.put(key, termTypesItem);
    return this;
  }

   /**
   * the term types used by the terminology
   * @return termTypes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TERM_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getTermTypes() {
    return termTypes;
  }


  @JsonProperty(JSON_PROPERTY_TERM_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTermTypes(Map<String, Metadata> termTypes) {
    this.termTypes = termTypes;
  }


  public TerminologyMetadata languages(Map<String, Metadata> languages) {
    this.languages = languages;
    return this;
  }

  public TerminologyMetadata putLanguagesItem(String key, Metadata languagesItem) {
    if (this.languages == null) {
      this.languages = new HashMap<>();
    }
    this.languages.put(key, languagesItem);
    return this;
  }

   /**
   * the languages used by the terminology
   * @return languages
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LANGUAGES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getLanguages() {
    return languages;
  }


  @JsonProperty(JSON_PROPERTY_LANGUAGES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLanguages(Map<String, Metadata> languages) {
    this.languages = languages;
  }


  public TerminologyMetadata relationshipTypes(Map<String, Metadata> relationshipTypes) {
    this.relationshipTypes = relationshipTypes;
    return this;
  }

  public TerminologyMetadata putRelationshipTypesItem(String key, Metadata relationshipTypesItem) {
    if (this.relationshipTypes == null) {
      this.relationshipTypes = new HashMap<>();
    }
    this.relationshipTypes.put(key, relationshipTypesItem);
    return this;
  }

   /**
   * the relationship types used by the terminology
   * @return relationshipTypes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RELATIONSHIP_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getRelationshipTypes() {
    return relationshipTypes;
  }


  @JsonProperty(JSON_PROPERTY_RELATIONSHIP_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRelationshipTypes(Map<String, Metadata> relationshipTypes) {
    this.relationshipTypes = relationshipTypes;
  }


  public TerminologyMetadata additionalRelationshipTypes(Map<String, Metadata> additionalRelationshipTypes) {
    this.additionalRelationshipTypes = additionalRelationshipTypes;
    return this;
  }

  public TerminologyMetadata putAdditionalRelationshipTypesItem(String key, Metadata additionalRelationshipTypesItem) {
    if (this.additionalRelationshipTypes == null) {
      this.additionalRelationshipTypes = new HashMap<>();
    }
    this.additionalRelationshipTypes.put(key, additionalRelationshipTypesItem);
    return this;
  }

   /**
   * the additional relationship types used by the terminology
   * @return additionalRelationshipTypes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ADDITIONAL_RELATIONSHIP_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getAdditionalRelationshipTypes() {
    return additionalRelationshipTypes;
  }


  @JsonProperty(JSON_PROPERTY_ADDITIONAL_RELATIONSHIP_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAdditionalRelationshipTypes(Map<String, Metadata> additionalRelationshipTypes) {
    this.additionalRelationshipTypes = additionalRelationshipTypes;
  }


  public TerminologyMetadata attributeNames(Map<String, Metadata> attributeNames) {
    this.attributeNames = attributeNames;
    return this;
  }

  public TerminologyMetadata putAttributeNamesItem(String key, Metadata attributeNamesItem) {
    if (this.attributeNames == null) {
      this.attributeNames = new HashMap<>();
    }
    this.attributeNames.put(key, attributeNamesItem);
    return this;
  }

   /**
   * the attribute names used by the terminology
   * @return attributeNames
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ATTRIBUTE_NAMES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getAttributeNames() {
    return attributeNames;
  }


  @JsonProperty(JSON_PROPERTY_ATTRIBUTE_NAMES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAttributeNames(Map<String, Metadata> attributeNames) {
    this.attributeNames = attributeNames;
  }


  public TerminologyMetadata other(Map<String, Metadata> other) {
    this.other = other;
    return this;
  }

  public TerminologyMetadata putOtherItem(String key, Metadata otherItem) {
    if (this.other == null) {
      this.other = new HashMap<>();
    }
    this.other.put(key, otherItem);
    return this;
  }

   /**
   * miscellaneous terminology metadata (terminology-specific)
   * @return other
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OTHER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getOther() {
    return other;
  }


  @JsonProperty(JSON_PROPERTY_OTHER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOther(Map<String, Metadata> other) {
    this.other = other;
  }


  public TerminologyMetadata semanticTypes(Map<String, Metadata> semanticTypes) {
    this.semanticTypes = semanticTypes;
    return this;
  }

  public TerminologyMetadata putSemanticTypesItem(String key, Metadata semanticTypesItem) {
    if (this.semanticTypes == null) {
      this.semanticTypes = new HashMap<>();
    }
    this.semanticTypes.put(key, semanticTypesItem);
    return this;
  }

   /**
   * the semantic types used by the terminology
   * @return semanticTypes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEMANTIC_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, Metadata> getSemanticTypes() {
    return semanticTypes;
  }


  @JsonProperty(JSON_PROPERTY_SEMANTIC_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSemanticTypes(Map<String, Metadata> semanticTypes) {
    this.semanticTypes = semanticTypes;
  }


  public TerminologyMetadata terminology(Terminology terminology) {
    this.terminology = terminology;
    return this;
  }

   /**
   * Get terminology
   * @return terminology
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Terminology getTerminology() {
    return terminology;
  }


  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTerminology(Terminology terminology) {
    this.terminology = terminology;
  }


  public TerminologyMetadata local(Boolean local) {
    this.local = local;
    return this;
  }

   /**
   * indicates whether this data element was created by local editing
   * @return local
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LOCAL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getLocal() {
    return local;
  }


  @JsonProperty(JSON_PROPERTY_LOCAL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLocal(Boolean local) {
    this.local = local;
  }


  public TerminologyMetadata modifiedBy(String modifiedBy) {
    this.modifiedBy = modifiedBy;
    return this;
  }

   /**
   * the identifier of the user who made the last modification
   * @return modifiedBy
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MODIFIED_BY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getModifiedBy() {
    return modifiedBy;
  }


  @JsonProperty(JSON_PROPERTY_MODIFIED_BY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setModifiedBy(String modifiedBy) {
    this.modifiedBy = modifiedBy;
  }


  public TerminologyMetadata created(Date created) {
    this.created = created;
    return this;
  }

   /**
   * the created date
   * @return created
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Date getCreated() {
    return created;
  }


  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreated(Date created) {
    this.created = created;
  }


  public TerminologyMetadata modified(Date modified) {
    this.modified = modified;
    return this;
  }

   /**
   * the last modified date
   * @return modified
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MODIFIED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Date getModified() {
    return modified;
  }


  @JsonProperty(JSON_PROPERTY_MODIFIED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setModified(Date modified) {
    this.modified = modified;
  }


  public TerminologyMetadata id(UUID id) {
    this.id = id;
    return this;
  }

   /**
   * the unique identifier
   * @return id
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(UUID id) {
    this.id = id;
  }


  public TerminologyMetadata active(Boolean active) {
    this.active = active;
    return this;
  }

   /**
   * indicates whether or not this data element is active
   * @return active
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getActive() {
    return active;
  }


  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setActive(Boolean active) {
    this.active = active;
  }


  /**
   * Return true if this TerminologyMetadata object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TerminologyMetadata terminologyMetadata = (TerminologyMetadata) o;
    return Objects.equals(this.termTypes, terminologyMetadata.termTypes) &&
        Objects.equals(this.languages, terminologyMetadata.languages) &&
        Objects.equals(this.relationshipTypes, terminologyMetadata.relationshipTypes) &&
        Objects.equals(this.additionalRelationshipTypes, terminologyMetadata.additionalRelationshipTypes) &&
        Objects.equals(this.attributeNames, terminologyMetadata.attributeNames) &&
        Objects.equals(this.other, terminologyMetadata.other) &&
        Objects.equals(this.semanticTypes, terminologyMetadata.semanticTypes) &&
        Objects.equals(this.terminology, terminologyMetadata.terminology) &&
        Objects.equals(this.local, terminologyMetadata.local) &&
        Objects.equals(this.modifiedBy, terminologyMetadata.modifiedBy) &&
        Objects.equals(this.created, terminologyMetadata.created) &&
        Objects.equals(this.modified, terminologyMetadata.modified) &&
        Objects.equals(this.id, terminologyMetadata.id) &&
        Objects.equals(this.active, terminologyMetadata.active);
  }

  @Override
  public int hashCode() {
    return Objects.hash(termTypes, languages, relationshipTypes, additionalRelationshipTypes, attributeNames, other, semanticTypes, terminology, local, modifiedBy, created, modified, id, active);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TerminologyMetadata {\n");
    sb.append("    termTypes: ").append(toIndentedString(termTypes)).append("\n");
    sb.append("    languages: ").append(toIndentedString(languages)).append("\n");
    sb.append("    relationshipTypes: ").append(toIndentedString(relationshipTypes)).append("\n");
    sb.append("    additionalRelationshipTypes: ").append(toIndentedString(additionalRelationshipTypes)).append("\n");
    sb.append("    attributeNames: ").append(toIndentedString(attributeNames)).append("\n");
    sb.append("    other: ").append(toIndentedString(other)).append("\n");
    sb.append("    semanticTypes: ").append(toIndentedString(semanticTypes)).append("\n");
    sb.append("    terminology: ").append(toIndentedString(terminology)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    modifiedBy: ").append(toIndentedString(modifiedBy)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    active: ").append(toIndentedString(active)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

